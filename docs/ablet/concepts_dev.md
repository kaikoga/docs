---
sidebar_position: 201
unlisted: true
---

# 概念（開発者向け）

## アーキテクチャ

### エントリポイントとコンテキストオブジェクト

エントリポイントはビルドの入力で、エントリポイントを元にしてコンテキストオブジェクトが生成されます。

:::note[NOTE]
エントリポイントとコンテキストオブジェクトは同一のオブジェクトである場合と、そうでない場合があります。
:::

### オペレーターコンポーネント

Abletのレイヤーに対して処理を指示するコンポーネントをオペレーターコンポーネントと呼びます。

処理を完了したオペレーターコンポーネントをコンテキストオブジェクトから `Object.DestroyImmediate()` などによって取り除くことが推奨されます。

### 事前条件

Abletに入力された、Abletが処理中の、またはAbletが出力したコンテキストオブジェクトについて、一般に満たされると考えられる条件を以下に示します。

- エントリポイントがプレハブの場合も、コンテキストオブジェクトはシーン上のオブジェクトになります。
- 処理対象はUniVRMなどの外部プラグインから扱う際のデータ整合性が取れていないことがあります。
- 全ての読み書き可能な参照は `null` が入っている可能性があり、また Missing である可能性があります。
- Abletの処理の適用はコンテキストオブジェクトまたは一時アセットのみを変更します。
- Abletの処理について、Undoの考慮は不要です。

## レイヤーの実行順

Abletのレイヤーの実行順はフェーズまたはレイヤーに対して `AddDependency()` を呼び出すことによって定義されます。

フェーズをIDまたは型パラメータで指定した場合の実行順は以下の通りになります。

- 直接指定した場合、フェーズの中で実行されます。
- `BeforeLayer<Phase>` を指定した場合、フェーズ開始前に実行されます。
- `NextLayer<Phase>` を指定した場合、フェーズ開始直後に実行されます。
- `AfterLayer<Phase>` を指定した場合、フェーズに含まれるレイヤーの実行完了後に実行されます。

特定のレイヤーをIDまたは型パラメータで指定した場合の実行順は以下の通りになります。

- 直接指定した場合、フェーズの中で実行されます。
- `BeforeLayer<Layer>` を指定した場合、対象のレイヤーの実行直前に実行されます。
- `NextLayer<Layer>` を指定した場合、対象のレイヤーの実行直後に実行されます。
- `AfterLayer<Layer>` を指定した場合、対象のレイヤーおよびレイヤーに依存する他レイヤーの実行完了後に実行されます。

:::tip[TIPS]
`BeforeLayer` 等をID文字列で指定する必要がある場合、対象のレイヤーIDに以下のプレフィクスを付加してください。

- `BeforeLayer` → `Ablet.Before.*`
- `NextLayer` → `Ablet.Next.*`
- `AfterLayer` → `Ablet.After.*`
:::

:::warning[WARNING]
フェーズ内のレイヤーの実行順や、同じレイヤーに依存するレイヤーの実行順は未定義です。

Abletのパッチバージョンで動作が変わる可能性があります。
:::

## Abletのフェーズ

Abletのレイヤーはいくつかのフェーズに分類され、定義されたフェーズの実行順に従って実行されます。

:::WARNING[warning]
以下の解釈は定まったものではありません。
:::

:::INFO[info]
Abletはフェーズ内での実行順の制御を積極的には推奨しない代わりに、フェーズは細かく分かれる傾向があります。

既に数多くのフェーズが定義されていますが、フェーズの実行順が変化しない限り、フェーズの追加提案には積極的です。
:::

### Importing

事前処理フェーズで、プラットフォーム特有のデータ構造を読み込みます。

### Converting

事前処理フェーズで、出力プラットフォーム向けの最小限のデータ構造をセットアップします。

Convertingフェーズが完了した段階で、指定されたプラットフォームへの出力対象として完全である必要があります。

:::note[NOTE]
いわゆるプラットフォーム変換処理は以下のいずれかの方法で行うことが期待されます。

- Importingフェーズでコンポーネントの読み込み時に変換する。
- 読み込まれたコンポーネントをConvertingフェーズで変換する。
- プラットフォーム非対応のコンポーネントをオペレーターコンポーネントとして解釈した上で、Transformingフェーズで変換処理を行う。
:::

### Pruning

準備フェーズで、処理対象外のオブジェクトを除外します。

### Populating

準備フェーズで、ビルド処理に必要なデータ構造がセットアップされていない場合、それを行います。

:::note[NOTE]
Transformingフェーズで動的に生成されるなどの理由でPopulatingフェーズでは確定できない内容はMaterializingフェーズで補完するようにしてください。
:::

### Generating

ビルドフェーズで、オペレーターコンポーネントを動的に生成します。

Generatingフェーズではコンテキストオブジェクトのヒエラルキー構造に対する移動・削除処理は行わないことが期待されます。

:::note[NOTE]
コンテキストオブジェクトの構造を変更しない処理はGeneratingまたはTransformingのうちどちらかのフェーズで行うことができます。
:::

### Transforming

ビルドフェーズで、オペレーターコンポーネントの設定に基づいてコンテキストオブジェクトの構造の変更を行います。

Transformingフェーズ以降でコンテキストオブジェクトの構造を変更するプラグインは、コンテキストオブジェクトの整合性を保つ責務を持ちます。

### Materializing

最適化フェーズで、データ出力に必要なデータ構造がセットアップされていない場合、それを行います。

コンテキストオブジェクトの振る舞いが変わりうる最後のフェーズです。

### Reducing

最適化フェーズで、コンテキストオブジェクトのリソースを圧縮します。

コンテキストオブジェクトの見た目が変わりうる最後のフェーズです。

### Collecting

最適化フェーズで、コンテキストオブジェクトのデータ構造の最適化を行います。

コンテキストオブジェクトを書き換えうる最後のフェーズです。

### Exporting 

事後処理フェーズで、コンテキストオブジェクトの読み取りのみを行い、プラットフォーム特有のフォーマットへのエクスポートなどを行います。

## NDMFプラグインをAbletに対応する

には、単にNDMFをAbletに置き換える方法と、Ablet NDMFハイブリッドプラグインを作成する方法があります。

考慮すべきいくつかの点があります：

### 全般
 
- NDMFは親切で、最適化されていて、多機能です。
  Abletはシンプルさを優先して処理速度を重視せず、プラットフォーム特有の機能を無視する傾向があります。
- NDMFはエディタ拡張ツールです。
  Abletでは基本機能からEditorアセンブリが排除されており、Runtimeアセンブリ（`autoReferenced = false`）です。

### プラットフォームの扱い

- NDMF（および、Modular Avatar）はVRChatのアバターが持つ機能セットをサポートするように設計されており、VRChatを含む少数のメジャーなプラットフォームのサポートが重視される傾向があります。
  AbletはVRCSDKおよびVRCSDKに同梱されるライブラリに依存しないことを前提の一つとしています。
- NDMFにとって、 `Platform` は出力先のことです。
  そのため、Basis FrameworkはNDMFにとって `Platform` の一つです（Basis Frameworkはプラットフォームではないにかかわらず）。
  Abletにとって、 `Platform` はアバターを示すマーカーコンポーネントのことです。
  そのため、Basis FrameworkはAbletにとっても `Platform` の一つです。
  その上、ResoniteはAbletの `Platform` ではありません（Resoniteはプラットフォームであるにかかわらず）。

### プラグイン定義関連

- NDMFではそれぞれの `Plugin` がいくつかの `Sequence` を定義し、それらは複数の `Pass` を持ちます。
  Abletではこれは入れ子の `Layer` で表現されます。
- NDMFのビルドフローはBuildPhaseで定義されます。
  Abletのビルドフェーズは特別な `Layer` です。
- NDMFの `Plugin` や `Pass` の前後関係は `Sequence` や `BeforePlugin()` / `AfterPlugin()` / `AfterPass()` などのAPIで定義され、対象をIDで指定します。
  Abletでは `AddDependency()` / `AddReverseDependency()` などのAPIを用い、 対象のLayerをIDで指定するほか、フェーズ内の相対位置を `BeforeLayer<T>` / `AfterLayer<T>` で指定します。
- これはプラグインに限りませんが、NDMFのプラグインAPI（プラグインやプラットフォームの定義）はEditorアセンブリです。
  AbletのプラグインAPIはRuntimeアセンブリです。
  エディタAPIはプラグインAPIに対する `Extension` として定義されます。

### 処理の実装
 
- NDMFには `State` や `Extension` などのビルド中に利用できるデータストレージがあります。
  Abletでは `Artifact` を用いてこれらを補完する必要があるでしょう

### 入出力

- NDMFのエラー出力は `ErrorReport` から行われます。
  Abletにも `ErrorReport` があります。
- NDMFは `ObjectRegistry` によってビルド中に変換されるオブジェクトのマッピングを記録し、 `ObjectReference` からそれにアクセスします。
  Abletでは `ObjectChain` がビルド中に変換されるオブジェクトのマッピングに相当し、ただのパスの遷移です。
- NDMFのエラー出力は揮発します。
  Abletのエラー出力はシリアライズされ、プレイモードの変更を生き延びます。
- NDMFはエラー出力などに利用できる固有のローカライズシステムを持ちます。
  Abletはローカライズシステムを持ちません。
  - 例えば、 CL4EE を利用することを想定しています。
